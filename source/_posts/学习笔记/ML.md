---
title: machine learning
date: 2022-09-11 11:57:00
tags: 
categories: 
- 机器学习
---

机器学习
<!--more-->

<!--
# 《机器学习》笔记
------

$welcome$ $to$ $9\frac{3}{4}$ $platform$

## [NFL定理($No Free Lunch Theorem)$](http://georgemaciunas.com/wp-content/uploads/2012/07/Wolpert_NLFoptimization-1.pdf )

(点击查看NFL定理论文)

> "小西，你知道吗，我现在写一个随机学习算法，可能会超过你写了三天的学习算法，你信不信？ "
>
> 小西抱紧自己的模型，“呵，我不信。 "
>
> "你知道NFL定理吗？"小瓜露出了意味深长的微笑。



NFL定理描述了一个简单的事实：

- 假设真实目标函数$f$**均匀分布**;
- 则不同学习算法在训练集$D$之外的样本产生的误差**期望相同**。

首先，学习算法没有绝对的“优劣”，那么如果学习算法$\alpha$在某些问题上比学习算法$\beta$优，那么必然存在一些问题，使得$\beta$比$\alpha$更优。

论文里有一段描述：$Any \space elevated  \space performance \space over  \space one \space class \space of \space  problems  \space  is  \space  exactly \space   paid  \space  for  \space  in \space   performance  \space  over \space   another  \space  class. $



西瓜书里对于NFL定理作出了简单的数学推导。



假设样本空间$S$和假设空间$H$都是离散的，此处我们假设问题为二分类问题。

将所有可能的$f$按照均匀分布，对误差求和：

$\sum_{f}{E{ote}(\alpha|D,f)=\sum_{f}\sum_{h}\sum_{x\in{S-D}}P(x)\mathbb I(h(x)!=f(x))P(h|D,\alpha)}$

​	$=\sum_{x\in{S-D}}P(x)\sum_{h}P(h|D,\alpha)\sum_{f}\mathbb I(h(x)!=f(x))$

​	$=\sum_{x\in{S-D}}P(x)\sum_{h}P(h|D,\alpha)\frac{1}{2}2^{|\rho|}$

​	$=\sum_{x\in{S-D}}P(x) \cdot1 \cdot\frac{1}{2}2^{|\rho|}$		





$P.S.$对于二分类问题，真实目标函数可以是值域为${\{0,1}\}$的任意函数$\rho$，函数空间则为$\{0,1\}^{|\rho|}$

$P.S.$因为$f$均匀分布，所以有一半的$f$对于$x$的预测与$h(x)$是不一致的

则我们的$\sum_{f}\mathbb I(h(x)!=f(x))=\frac{1}{2}2^{|\rho|}$



根据公式的推导，我们发现，不同的学习算法，产生的误差的期望性能相同。

但是这是基于**真实目标函数均匀分布**的前提。



由此，NFL定理的介绍就告一段落了，那么NFL定理给我们的启示是什么呢？

当我们得到了不同的学习算法，如何判断哪一个更“好”呢?

答案是——**归纳偏好**($inductive \  bias$)

正是这个思路将脱离具体问题的学习算法拉回正轨。



> 学习完NFL定理，小西对小瓜说：你的随机算法也许能够在某些问题上赢过我的算法，从概率的角度来说，你必须要保证所有问题出现的机会都相等，才能跟我打个平手。但是具体问题应该具体分析，。
>
> 小瓜惭愧地说：你说得对，**学习算法的自身归纳偏好与问题是否匹配**是很重要的。
>
> 理解了NFL定理的含义，小西和小瓜决定吃一个西瓜庆祝一下。







## 第一章 绪论 课后作业

![](https://img2018.cnblogs.com/blog/1560652/201907/1560652-20190731182151837-1903270784.png)

### 习题1.1--版本空间

> 假设空间($hypothesis \ space$)
>
> ​	定义1：所有可能的函数构成的空间称为假设空间；
>
> ​	定义2：研究对象所有属性可能取值的组合;
>
> ​	定义3：模型属于由输入空间到输出空间的映射的集合；
>
> 版本空间($version \ space$)
>
> ​	定义1：训练集$D$的所有假设的*子集集合*



习题1.1表中有两组数据:

​	1.（色泽=青绿）$\bigwedge$(根蒂=蜷缩)$\bigwedge$(敲声=浊响)===好瓜

​	2.（色泽=乌黑）$\bigwedge$(根蒂=稍蜷)$\bigwedge$(敲声=清脆)===坏瓜

加上通配符$*$，能够组成的可能假设有$(3 \times 3 \times 3)$种；

另外，我们还需要在假设空间内加上一种情况$\emptyset$,也就是根本不存在好瓜这个概念

则假设空间内有$28$种假设，经过筛选，我们找到了$7$种假设,组成版本空间，分别为：

> 1.（色泽=青绿）$\bigwedge$ (根蒂=蜷缩)$\bigwedge$(敲声=浊响)=好瓜
>
> 2.（色泽=青绿）$\bigwedge$  (根蒂=蜷缩)$\bigwedge$(敲声=   *  )=好瓜
>
> 3.（色泽=青绿）$\bigwedge$ (根蒂=   *    )$\bigwedge$(敲声=浊响)=好瓜
>
> 4.（色泽=  *    ）$\bigwedge$ (根蒂= 蜷缩)$\bigwedge$(敲声=浊响)=好瓜
>
> 5.（色泽=青绿）$\bigwedge$(根蒂=    *    )$\bigwedge$(敲声=   *  )=好瓜
>
> 6.（色泽=   *   ）$\bigwedge$(根蒂=   *    )$\bigwedge$(敲声=浊响)=好瓜
>
> 7.（色泽=   *   ）$\bigwedge$ (根蒂=蜷缩)$\bigwedge$(敲声=    *  )=好瓜

选取过程此处不再赘述。

引用网上的一句话："一般来说，版本空间是正例的泛化"。





### 习题1.2--析取范式

题目:析合范式$(disjunctive \ normal \ form)$使得空间具有更强的表示能力，若使用k个合取式的析合范式来表达表1.1的西瓜分类问题的假设空间，估算共有多少种可能的假设

- 如果不考虑冗余情况，则最多可能的假设数为$\sum_{k=1}^{n}{C_{n}^{k}}$;

- 接下来我们考虑冗余情况;

- 编程思路：

  ​	由于需要枚举k种析合范式的组合方案，所以用dfs+记录路径+剪枝来解决：

  ​	已知有a,b,c三个人，他们分别可以选择$A_1$,$A_2$和$B_1$,$B_2$,$B_3$和$C_1$,$C_2$,$C_3$物体或者可以不选物体。

  ​	然后我们考虑用状态压缩来表示枚举结果。

  ​	并且这里用状态压缩还有一个重要的好处，就是题目条件中：

  ​	如果$A\subset B$,则$A|B=B$或者$A\&B=A$，对每一种方案使用哈希的方法，就可以直接对方案进行位运算，相对比较高效。

  ​	有一个需要注意的事情：状态压缩的时候，通配符应该压缩为111，而不是000

  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  const int max_size=(262143);
  int hypo_1[50]={0xff,0xf9,0xfa,0xfc,0xcf,0xd7,0xe7,0x7f,
                  0xbf,0xc9,0xca,0xcc,0xd1,0xd2,0xd4,0xe1,
                  0xe2,0xe4,0x79,0x7a,0x7c,0xb9,0xba,0xbc,
                  0x4f,0x57,0x67,0x8f,0x97,0xa7,0x49,0x4a,
                  0x4c,0x51,0x52,0x54,0x61,0x62,0x64,0x89,
                  0x8a,0x8c,0x91,0x92,0x94,0xa1,0xa2,0xa4}; 
  
  int leaf[20]={0x49,0x4a,0x4c,0x51,0x52,0x54,0x61,0x62,0x64,
                0x89,0x8a,0x8c,0x91,0x92,0x94,0xa1,0xa2,0xa4};
  
  int hypo_2[48],ans[20],vis[max_size];
  void dfs(int st,int cur,int k,int pre,int vis[]){
      if(cur==k){
          ans[k]++;
          return;
      }
      for(int i=st+1;i<=48;i++){
          int m=hypo_2[i]|pre;
          if(m==pre)continue;
          if(m==0x3ffff)continue;
          if(vis[m])continue;
          vis[m]++;
          dfs(i,cur+1,k,m,vis);
          vis[m]--;
      }
  }
  int main(){
      for(int i=0;i<48;i++){
          for(int j=0;j<18;j++){
              if((hypo_1[i]|leaf[j])==hypo_1[i])
                  hypo_2[i]|=(1<<j);
          }
      }
      for(int k=1;k<=18;k++){
          for(int i=0;i<48;i++){
              memset(vis,0,sizeof(vis));
              vis[hypo_2[i]]++;
              dfs(i,1,k,hypo_2[i],vis);
              vis[hypo_2[i]]++;
          }
          cout<<ans[k]<<" ";
      }
  }
  ```

  

### 习题1.3设计归纳偏好

题目:如果数据包含噪声，则假设空间内可能不存在与所有训练样本都一致的假设。

​	在这种情况下，设计一种归纳偏好用于假设选择。



首先要明确，归纳偏好$(inductive \ bias)$和特征选择$(feature \ selection)$是有区别的

前者是基于对某**领域知识**的认知，而后者是基于**训练样本**的数据。

（详见笔记的另一章节：归纳偏好与特征选择）



对于包含噪声的数据，数据中不存在训练错误为0的假设，我们的方案有：

> 方案一：利用相关领域知识，将每个属性设置不同的权重，再设计一个估值函数，将误差代入函数得到一个误差值，再将不同模型的误差值进行比较。
>
> 方案二：在各种分类都相近或者相似的情况下，也可以考虑利用“奥卡姆剃刀”原则，选择最简单的模型。
>
> 方案三：牺牲一部分数据，将相同特征但是根据假设得到的标签不同的数据全部删除。或者考虑只保留正例，或者只保留反例，或者采取更复杂的保留方案。

这个问题我认为方案二不对。这个问题留待以后解决。

### 习题1.4证明$NFL$定理

换用其他性能度量函数$l$，将书中公式改为：

​	$E_{ote}(\alpha|D,f)=\sum_h\sum_{x\in{S-D}}P(x)l(h(x),f(x)))P(h|D,\alpha)$

求证$NFL$定理仍然成立。

证明：

​	$\sum_fE_{ote}(\alpha|D,f)=\sum_f\sum_h\sum_{x\in{S-D}}P(x)l(h(x),f(x))P(h|D,\alpha)$

$=\sum_{x\in{S-D}}P(x)\sum_fl(h(x),f(x))\sum_hP(h|D,\alpha)$

$=\sum_{x\in{S-D}}P(x)\sum_fl(h(x),f(x))\centerdot1$

现在求证$\sum_fl(h(x),f(x))$是常数

首先和书中的证明思路一样，考虑二分类问题，训练结果只存在$或0或1$；

那么对于任意的性能度量函数$l(h(x),f(x))$有

$是某常数l(h(x)!=f(x))+l(h(x)=f(x))=C,C是某常数$

直观一点就是：

​	$，l(0,0)=l(1,1)，l(0,1)=l(1,0)$

​        $l(0,0)+l(1,0)+l(1,1)+l(0,1)=A$ 

得到:

​	$是某常数l(h(x)!=f(x))+l(h(x)=f(x))=C,C是某常数$

由此结论，由由于$f$均匀分布，所以

由于$f$均匀分布，所以$\sum_fl(h(x),f(x))=\frac{1}{2}2^{|\rho|}(l(h(x)=f(x))+l(h(x)!=f(x)))=\frac{1}{2}2^{|\rho|}C$

则$NFL$定理得证。





## 第二章 模型评估与选择 答案

### 习题2.1-留出法习题

题目：

> 数据集包含1000个样本，500个正例，500个反例。将其划分为包含70%样本的训练集，和30%的测试集，用于留出法评估，有多少种划分方法？

答案:$(C_{500}^{350})^2$种

### 习题2.2-交叉验证法和留一法习题

题目：

> 数据集包含100个样本，正反例各一半。
>
> 假定学习算法所产生的模型是将新样本预测为训练样本数较多的类别（训练样本数相同时随机猜测），试给出用10折交叉验证法和留一法分别对错误率进行评估所得的结果。

答案：

10折交叉验证法：

​	由于交叉验证法的子集选取方式为**分层抽样**,根据原数据集的数据分布而划分的

​	所以子集中的每个样本都是$正例数反例数正例数==反例数$，并且测试样本也为$正例数反例数正例数==反例数$

​	所以错误率为$50\%$

留一法：

​	留一法将100个样本分为100个子集，99个样本用于训练，1个样本用于测试。

​	可以知道如果99个样本中，正例多于反例，那么测试用的样本就是反例，学习算法返回正，反之亦然。所以留一法的错误率是$100\%$



### 习题2.3-F1与BEP的关系

题目：

> 若学习器A的F1值比学习器B的高，试分析学习器A的BEP值是否也比B高

答案1：

​	是。

​	当$P==R$时，$BEP=R=P$,$\frac{1}{F1}=\frac{1}{2}(\frac{1}{P}+\frac{1}{R})$.  $F1=R=P$

​	则$BEP_A>BEP_B$

答案2：

​	也可以换个角度考虑，F1值表示对查准率与查全率的重视程度相同。

​	那么在$B==P$的情况下，也就是对查准率与查全率的重视程度相同时，

​	$F1_A>F1_B$,则$BEP_A>BEP_B$

答案3：

​	没有必然联系。

(哪一种是对的呢？留待以后去解决，个人倾向第一个解释)

### 习题2.4-TPR,TFR,P,R的关系

试述真正例率(TPR)，假正例率(FPR)与查准率(P)，查全率(R)之间的联系

$TPR=\frac{TP}{TP+FN}=R$

$FPR=\frac{FP}{FP+TN}$

$P=\frac{TP}{TP+FP}$

当$TPR,R$变大的时候，$P$是会相应变小的，因为希望预测尽可能多的正例时，就会牺牲一部分的准确率。

由于$TN$不变，将$FP$看作未知数，那么对于函数$f(x)=\frac{x}{x+k}$求导可知，当$x$增大时，$f(x)$增大

则对于$P$来说，$FP$增大，$P$减小

所以结论就是：当$FPR$，$R$，或者$TPR$增大时，$P$减小

### 习题2.5-AUC的公式证明

试证明式子：

​	$AUC=1-l_{rank}$

​	已知$l_{rank}=\frac{1}{m^{+} m^{-}} \sum_{x^{+} \in D^+} \sum_{x^{-} \in D^{-}}(\mathbb I(f(x^{+})< f(x^{-}))+\frac{1}{2} \mathbb I(f(x^{+})=f(x^{-})))$

证明：

> 在书上我们已经知道了AUC图线的绘制方法
>
> 真正例$f(x^{+}) >f(x^{-})$时，标记点坐标为$(x,y+\frac{1}{m^{+}})$,垂直于水平轴
>
> 假正例$f(x^{+}) <f(x^{-})$时，标记点坐标为$(x+\frac{1}{m^{-}},y)$,平行于水平轴
>
> 当$f(x^{+}) =f(x^{-})$时，标记点为$(x+\frac{1}{m},y+\frac{1}{m})$是一条斜线段，这个地方书上没有说，注意，也就是因为这个原因，所以注意到在$l_{rank}$函数中，当正==反时，书里说的"罚分"是0.5，而不是1，这个地方可以类比微积分的求解方法

 	

$AUC= \frac{1}{m^{+} m^{-}} \sum_{x^{+} \in D^+} \sum_{x^{-} \in D^{-}}(\mathbb I(f(x^{+})>f(x^{-}))+ \frac{1}{2} \mathbb I(f(x^{+})=f(x^{-})))$

​	则$AUC=1-l_{rank}$

​	（这个证明不太对）

### 习题2.6-ROC与错误率

试述ROC曲线与错误率的关系

它们分类任务中的两种性能度量

i.错误率是分类错误的样本在总样本中所占的比例，但是并不能够判断预测结果的查全和查准率

ii.$ROC$曲线上的点是$(FPR,TPR)$，$(1-TPR+FPR)$是错误率 -->
